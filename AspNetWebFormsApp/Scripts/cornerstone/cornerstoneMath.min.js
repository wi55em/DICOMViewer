/*! cornerstone-math - 0.1.8 - 2019-01-16 | (c) 2017 Chris Hafey | https://github.com/cornerstonejs/cornerstoneMath */
!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("cornerstone-math", [], e) : "object" == typeof exports ? exports["cornerstone-math"] = e() : t.cornerstoneMath = e() }(window, function () { return function (t) { var e = {}; function i(n) { if (e[n]) return e[n].exports; var o = e[n] = { i: n, l: !1, exports: {} }; return t[n].call(o.exports, o, o.exports, i), o.l = !0, o.exports } return i.m = t, i.c = e, i.d = function (t, e, n) { i.o(t, e) || Object.defineProperty(t, e, { configurable: !1, enumerable: !0, get: n }) }, i.r = function (t) { Object.defineProperty(t, "__esModule", { value: !0 }) }, i.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return i.d(e, "a", e), e }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, i.p = "", i(i.s = 9) }([function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.clamp = function (t, e, i) { return t < e ? e : t > i ? i : t }, e.degToRad = function (t) { return t * (Math.PI / 180) }, e.radToDeg = function (t) { return t * (180 / Math.PI) }, e.sign = function (t) { return "number" == typeof t ? t ? t < 0 ? -1 : 1 : t == t ? 0 : NaN : NaN } }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n, o = i(3), s = (n = o) && n.__esModule ? n : { default: n }, r = i(0); var a, h, u, c, l, f = function (t, e, i) { this.x = t || 0, this.y = e || 0, this.z = i || 0 }; f.prototype = { constructor: f, set: function (t, e, i) { return this.x = t, this.y = e, this.z = i, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) } }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyAxisAngle: (l = void 0, function (t, e) { return void 0 === l && (l = new s.default), this.applyQuaternion(l.setFromAxisAngle(t.normalize(), e)), this }), applyMatrix3: function (t) { var e = this.x, i = this.y, n = this.z, o = t.elements; return this.x = o[0] * e + o[3] * i + o[6] * n, this.y = o[1] * e + o[4] * i + o[7] * n, this.z = o[2] * e + o[5] * i + o[8] * n, this }, applyMatrix4: function (t) { var e = this.x, i = this.y, n = this.z, o = t.elements; return this.x = o[0] * e + o[4] * i + o[8] * n + o[12], this.y = o[1] * e + o[5] * i + o[9] * n + o[13], this.z = o[2] * e + o[6] * i + o[10] * n + o[14], this }, applyProjection: function (t) { var e = this.x, i = this.y, n = this.z, o = t.elements, s = 1 / (o[3] * e + o[7] * i + o[11] * n + o[15]); return this.x = (o[0] * e + o[4] * i + o[8] * n + o[12]) * s, this.y = (o[1] * e + o[5] * i + o[9] * n + o[13]) * s, this.z = (o[2] * e + o[6] * i + o[10] * n + o[14]) * s, this }, applyQuaternion: function (t) { var e = this.x, i = this.y, n = this.z, o = t.x, s = t.y, r = t.z, a = t.w, h = a * e + s * n - r * i, u = a * i + r * e - o * n, c = a * n + o * i - s * e, l = -o * e - s * i - r * n; return this.x = h * a + l * -o + u * -r - c * -s, this.y = u * a + l * -s + c * -o - h * -r, this.z = c * a + l * -r + h * -s - u * -o, this }, transformDirection: function (t) { var e = this.x, i = this.y, n = this.z, o = t.elements; return this.x = o[0] * e + o[4] * i + o[8] * n, this.y = o[1] * e + o[5] * i + o[9] * n, this.z = o[2] * e + o[6] * i + o[10] * n, this.normalize(), this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { if (0 !== t) { var e = 1 / t; this.x *= e, this.y *= e, this.z *= e } else this.x = 0, this.y = 0, this.z = 0; return this }, min: function (t) { return this.x > t.x && (this.x = t.x), this.y > t.y && (this.y = t.y), this.z > t.z && (this.z = t.z), this }, max: function (t) { return this.x < t.x && (this.x = t.x), this.y < t.y && (this.y = t.y), this.z < t.z && (this.z = t.z), this }, clamp: function (t, e) { return this.x < t.x ? this.x = t.x : this.x > e.x && (this.x = e.x), this.y < t.y ? this.y = t.y : this.y > e.y && (this.y = e.y), this.z < t.z ? this.z = t.z : this.z > e.z && (this.z = e.z), this }, clampScalar: (u = void 0, c = void 0, function (t, e) { return void 0 === u && (u = new f, c = new f), u.set(t, t, t), c.set(e, e, e), this.clamp(u, c) }), floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.multiplyScalar(-1) }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (t) { var e = this.length(); return 0 !== e && t !== e && this.multiplyScalar(t / e), this }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, cross: function (t, e) { if (void 0 !== e) return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e); var i = this.x, n = this.y, o = this.z; return this.x = n * t.z - o * t.y, this.y = o * t.x - i * t.z, this.z = i * t.y - n * t.x, this }, crossVectors: function (t, e) { var i = t.x, n = t.y, o = t.z, s = e.x, r = e.y, a = e.z; return this.x = n * a - o * r, this.y = o * s - i * a, this.z = i * r - n * s, this }, projectOnVector: (a = void 0, h = void 0, function (t) { return void 0 === a && (a = new f), a.copy(t).normalize(), h = this.dot(a), this.copy(a).multiplyScalar(h) }), projectOnPlane: function () { var t = void 0; return function (e) { return void 0 === t && (t = new f), t.copy(this).projectOnVector(e), this.sub(t) } }(), reflect: function () { var t = void 0; return function (e) { return void 0 === t && (t = new f), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e))) } }(), angleTo: function (t) { var e = this.dot(t) / (this.length() * t.length()); return Math.acos((0, r.clamp)(e, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, i = this.y - t.y, n = this.z - t.z; return e * e + i * i + n * n }, setFromMatrixPosition: function (t) { return this.x = t.elements[12], this.y = t.elements[13], this.z = t.elements[14], this }, setFromMatrixScale: function (t) { var e = this.set(t.elements[0], t.elements[1], t.elements[2]).length(), i = this.set(t.elements[4], t.elements[5], t.elements[6]).length(), n = this.set(t.elements[8], t.elements[9], t.elements[10]).length(); return this.x = e, this.y = i, this.z = n, this }, setFromMatrixColumn: function (t, e) { var i = 4 * t, n = e.elements; return this.x = n[i], this.y = n[i + 1], this.z = n[i + 2], this }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t) { return this.x = t[0], this.y = t[1], this.z = t[2], this }, toArray: function () { return [this.x, this.y, this.z] }, clone: function () { return new f(this.x, this.y, this.z) } }, e.default = f }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n = i(0); function o(t) { return t * t } function s(t, e) { return o(t.x - e.x) + o(t.y - e.y) } var r = { distanceToPoint: function (t, e) { return Math.sqrt(function (t, e) { var i = s(t.start, t.end); if (0 === i) return s(e, t.start); var n = ((e.x - t.start.x) * (t.end.x - t.start.x) + (e.y - t.start.y) * (t.end.y - t.start.y)) / i; return s(e, n < 0 ? t.start : n > 1 ? t.end : { x: t.start.x + n * (t.end.x - t.start.x), y: t.start.y + n * (t.end.y - t.start.y) }) }(t, e)) }, intersectLine: function (t, e) { var i, o, s, r, a, h, u, c, l, f, y, d = {}, p = t.start.x, x = t.start.y, m = t.end.x, v = t.end.y, g = e.start.x, z = e.start.y, b = e.end.x, M = e.end.y, w = void 0; if (f = (i = v - x) * b + (s = p - m) * M + (a = m * x - p * v), (0 === (l = i * g + s * z + a) || 0 === f || (0, n.sign)(l) !== (0, n.sign)(f)) && (c = (o = M - z) * m + (r = g - b) * v + (h = b * z - g * M), 0 === (u = o * p + r * x + h) || 0 === c || (0, n.sign)(u) !== (0, n.sign)(c))) { y = i * r - o * s, w = s * h - r * a; var R = parseFloat(w / y); w = o * a - i * h; var P = parseFloat(w / y); return d.x = R, d.y = P, d } } }; e.default = r }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n = function (t, e, i, n) { this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1 }; n.prototype.setFromAxisAngle = function (t, e) { var i = e / 2, n = Math.sin(i); return this.x = t.x * n, this.y = t.y * n, this.z = t.z * n, this.w = Math.cos(i), this }, n.prototype.multiplyQuaternions = function (t, e) { var i = t.x, n = t.y, o = t.z, s = t.w, r = e.x, a = e.y, h = e.z, u = e.w; return this.x = i * u + s * r + n * h - o * a, this.y = n * u + s * a + o * r - i * h, this.z = o * u + s * h + i * a - n * r, this.w = s * u - i * r - n * a - o * h, this }, n.prototype.setFromRotationMatrix = function (t) { var e = t.elements, i = e[0], n = e[4], o = e[8], s = e[1], r = e[5], a = e[9], h = e[2], u = e[6], c = e[10], l = i + r + c, f = void 0; return l > 0 ? (f = .5 / Math.sqrt(l + 1), this.w = .25 / f, this.x = (u - a) * f, this.y = (o - h) * f, this.z = (s - n) * f) : i > r && i > c ? (f = 2 * Math.sqrt(1 + i - r - c), this.w = (u - a) / f, this.x = .25 * f, this.y = (n + s) / f, this.z = (o + h) / f) : r > c ? (f = 2 * Math.sqrt(1 + r - i - c), this.w = (o - h) / f, this.x = (n + s) / f, this.y = .25 * f, this.z = (a + u) / f) : (f = 2 * Math.sqrt(1 + c - i - r), this.w = (s - n) / f, this.x = (o + h) / f, this.y = (a + u) / f, this.z = .25 * f), this }, e.default = n }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n, o = i(2), s = (n = o) && n.__esModule ? n : { default: n }; function r(t) { return { topLeft: { x: t.left, y: t.top }, bottomRight: { x: t.left + t.width, y: t.top + t.height } } } var a = { distanceToPoint: function (t, e) { var i = 655535; return function (t) { return [{ start: { x: t.left, y: t.top }, end: { x: t.left + t.width, y: t.top } }, { start: { x: t.left + t.width, y: t.top }, end: { x: t.left + t.width, y: t.top + t.height } }, { start: { x: t.left + t.width, y: t.top + t.height }, end: { x: t.left, y: t.top + t.height } }, { start: { x: t.left, y: t.top + t.height }, end: { x: t.left, y: t.top } }] }(t).forEach(function (t) { var n = s.default.distanceToPoint(t, e); n < i && (i = n) }), i }, getIntersectionRect: function (t, e) { var i = { topLeft: {}, bottomRight: {} }; if (function (t, e) { var i = void 0, n = void 0, o = r(t), s = r(e); return i = t.width >= 0 ? e.width >= 0 ? !(o.bottomRight.x <= s.topLeft.x || s.bottomRight.x <= o.topLeft.x) : !(o.bottomRight.x <= s.bottomRight.x || s.topLeft.x <= o.topLeft.x) : e.width >= 0 ? !(o.topLeft.x <= s.topLeft.x || s.bottomRight.x <= o.bottomRight.x) : !(o.topLeft.x <= s.bottomRight.x || s.topLeft.x <= o.bottomRight.x), n = t.height >= 0 ? e.height >= 0 ? !(o.bottomRight.y <= s.topLeft.y || s.bottomRight.y <= o.topLeft.y) : !(o.bottomRight.y <= s.bottomRight.y || s.topLeft.y <= o.topLeft.y) : e.height >= 0 ? !(o.topLeft.y <= s.topLeft.y || s.bottomRight.y <= o.bottomRight.y) : !(o.topLeft.y <= s.bottomRight.y || s.top <= o.bottomRight.y), i && n }(t, e)) { var n = r(t), o = r(e); return t.width >= 0 ? e.width >= 0 ? (i.topLeft.x = Math.max(n.topLeft.x, o.topLeft.x), i.bottomRight.x = Math.min(n.bottomRight.x, o.bottomRight.x)) : (i.topLeft.x = Math.max(n.topLeft.x, o.bottomRight.x), i.bottomRight.x = Math.min(n.bottomRight.x, o.topLeft.x)) : e.width >= 0 ? (i.topLeft.x = Math.min(n.topLeft.x, o.bottomRight.x), i.bottomRight.x = Math.max(n.bottomRight.x, o.topLeft.x)) : (i.topLeft.x = Math.min(n.topLeft.x, o.topLeft.x), i.bottomRight.x = Math.max(n.bottomRight.x, o.bottomRight.x)), t.height >= 0 ? e.height >= 0 ? (i.topLeft.y = Math.max(n.topLeft.y, o.topLeft.y), i.bottomRight.y = Math.min(n.bottomRight.y, o.bottomRight.y)) : (i.topLeft.y = Math.max(n.topLeft.y, o.bottomRight.y), i.bottomRight.y = Math.min(n.bottomRight.y, o.topLeft.y)) : e.height >= 0 ? (i.topLeft.y = Math.min(n.topLeft.y, o.bottomRight.y), i.bottomRight.y = Math.max(n.bottomRight.y, o.topLeft.y)) : (i.topLeft.y = Math.min(n.topLeft.y, o.topLeft.y), i.bottomRight.y = Math.max(n.bottomRight.y, o.bottomRight.y)), i } } }; e.default = a }, function (t, e, i) { "use strict"; function n(t, e) { return { x: t.x - e.x, y: t.y - e.y } } function o(t, e) { return Math.sqrt(s(t, e)) } function s(t, e) { var i = n(t, e); return i.x * i.x + i.y * i.y } Object.defineProperty(e, "__esModule", { value: !0 }); var r = { subtract: n, copy: function (t) { return { x: t.x, y: t.y } }, pageToPoint: function (t) { return { x: t.pageX, y: t.pageY } }, distance: o, distanceSquared: s, insideRect: function (t, e) { return !(t.x < e.left || t.x > e.left + e.width || t.y < e.top || t.y > e.top + e.height) }, findClosestPoint: function (t, e) { var i = [], n = void 0; return t.forEach(function (t, s) { var r = o(t, e); i.push(r), n = 0 === s ? r : Math.min(r, n) }), t[i.indexOf(n)] } }; e.default = r }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n, o = i(1), s = (n = o) && n.__esModule ? n : { default: n }; var r, a, h = function (t, e) { this.normal = void 0 !== t ? t : new s.default(1, 0, 0), this.constant = void 0 !== e ? e : 0 }; h.prototype = { constructor: h, set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, i, n) { return this.normal.set(t, e, i), this.constant = n, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: (r = new s.default, a = new s.default, function (t, e, i) { var n = r.subVectors(i, e).cross(a.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(n, t), this }), copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { var t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return this.orthoPoint(t, e).sub(t).negate() }, orthoPoint: function (t, e) { var i = this.distanceToPoint(t); return (e || new s.default).copy(this.normal).multiplyScalar(i) }, isIntersectionLine: function (t) { var e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end); return e < 0 && i > 0 || i < 0 && e > 0 }, intersectLine: function () { var t = new s.default; return function (e, i) { var n = i || new s.default, o = e.delta(t), r = this.normal.dot(o); if (0 === r) return 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0; var a = -(e.start.dot(this.normal) + this.constant) / r; return a < 0 || a > 1 ? void 0 : n.copy(o).multiplyScalar(a).add(e.start) } }(), intersectPlane: function (t) { var e = this.normal.clone().cross(t.normal), i = { origin: new s.default, direction: e }; if (this.normal.clone().cross(t.normal).length < 1e-10) return i.direction = new s.default, i; var n = this.constant, o = t.constant, r = this.normal.clone().dot(t.normal), a = -(n - o * r) / (1 - r * r), h = -(o - n * r) / (1 - r * r); return i.origin = this.normal.clone().multiplyScalar(a).add(t.normal.clone().multiplyScalar(h)), i }, coplanarPoint: function (t) { return (t || new s.default).copy(this.normal).multiplyScalar(-this.constant) }, translate: function (t) { return this.constant = this.constant - t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant }, clone: function () { return (new h).copy(this) } }, e.default = h }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n, o = i(1), s = (n = o) && n.__esModule ? n : { default: n }; var r = function (t, e, i, n, o, s, r, a, h, u, c, l, f, y, d, p) { this.elements = new Float32Array(16); var x = this.elements; x[0] = void 0 !== t ? t : 1, x[4] = e || 0, x[8] = i || 0, x[12] = n || 0, x[1] = o || 0, x[5] = void 0 !== s ? s : 1, x[9] = r || 0, x[13] = a || 0, x[2] = h || 0, x[6] = u || 0, x[10] = void 0 !== c ? c : 1, x[14] = l || 0, x[3] = f || 0, x[7] = y || 0, x[11] = d || 0, x[15] = void 0 !== p ? p : 1 }; r.prototype.makeRotationFromQuaternion = function (t) { var e = this.elements, i = t.x, n = t.y, o = t.z, s = t.w, r = i + i, a = n + n, h = o + o, u = i * r, c = i * a, l = i * h, f = n * a, y = n * h, d = o * h, p = s * r, x = s * a, m = s * h; return e[0] = 1 - (f + d), e[4] = c - m, e[8] = l + x, e[1] = c + m, e[5] = 1 - (u + d), e[9] = y - p, e[2] = l - x, e[6] = y + p, e[10] = 1 - (u + f), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, r.prototype.multiplyMatrices = function (t, e) { var i = t.elements, n = e.elements, o = this.elements, s = i[0], r = i[4], a = i[8], h = i[12], u = i[1], c = i[5], l = i[9], f = i[13], y = i[2], d = i[6], p = i[10], x = i[14], m = i[3], v = i[7], g = i[11], z = i[15], b = n[0], M = n[4], w = n[8], R = n[12], P = n[1], L = n[5], T = n[9], S = n[13], _ = n[2], V = n[6], q = n[10], j = n[14], E = n[3], k = n[7], O = n[11], A = n[15]; return o[0] = s * b + r * P + a * _ + h * E, o[4] = s * M + r * L + a * V + h * k, o[8] = s * w + r * T + a * q + h * O, o[12] = s * R + r * S + a * j + h * A, o[1] = u * b + c * P + l * _ + f * E, o[5] = u * M + c * L + l * V + f * k, o[9] = u * w + c * T + l * q + f * O, o[13] = u * R + c * S + l * j + f * A, o[2] = y * b + d * P + p * _ + x * E, o[6] = y * M + d * L + p * V + x * k, o[10] = y * w + d * T + p * q + x * O, o[14] = y * R + d * S + p * j + x * A, o[3] = m * b + v * P + g * _ + z * E, o[7] = m * M + v * L + g * V + z * k, o[11] = m * w + v * T + g * q + z * O, o[15] = m * R + v * S + g * j + z * A, this }, r.prototype.multiply = function (t, e) { return void 0 !== e ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, r.prototype.getInverse = function (t, e) { var i = this.elements, n = t.elements, o = n[0], s = n[4], r = n[8], a = n[12], h = n[1], u = n[5], c = n[9], l = n[13], f = n[2], y = n[6], d = n[10], p = n[14], x = n[3], m = n[7], v = n[11], g = n[15]; i[0] = c * p * m - l * d * m + l * y * v - u * p * v - c * y * g + u * d * g, i[4] = a * d * m - r * p * m - a * y * v + s * p * v + r * y * g - s * d * g, i[8] = r * l * m - a * c * m + a * u * v - s * l * v - r * u * g + s * c * g, i[12] = a * c * y - r * l * y - a * u * d + s * l * d + r * u * p - s * c * p, i[1] = l * d * x - c * p * x - l * f * v + h * p * v + c * f * g - h * d * g, i[5] = r * p * x - a * d * x + a * f * v - o * p * v - r * f * g + o * d * g, i[9] = a * c * x - r * l * x - a * h * v + o * l * v + r * h * g - o * c * g, i[13] = r * l * f - a * c * f + a * h * d - o * l * d - r * h * p + o * c * p, i[2] = u * p * x - l * y * x + l * f * m - h * p * m - u * f * g + h * y * g, i[6] = a * y * x - s * p * x - a * f * m + o * p * m + s * f * g - o * y * g, i[10] = s * l * x - a * u * x + a * h * m - o * l * m - s * h * g + o * u * g, i[14] = a * u * f - s * l * f - a * h * y + o * l * y + s * h * p - o * u * p, i[3] = c * y * x - u * d * x - c * f * m + h * d * m + u * f * v - h * y * v, i[7] = s * d * x - r * y * x + r * f * m - o * d * m - s * f * v + o * y * v, i[11] = r * u * x - s * c * x - r * h * m + o * c * m + s * h * v - o * u * v, i[15] = s * c * f - r * u * f + r * h * y - o * c * y - s * h * d + o * u * d; var z = o * i[0] + h * i[4] + f * i[8] + x * i[12]; if (0 === z) { var b = "Matrix4.getInverse(): can't invert matrix, determinant is 0"; if (e) throw new Error(b); return console.warn(b), this.identity(), this } return this.multiplyScalar(1 / z), this }, r.prototype.applyToVector3Array = function () { var t = new s.default; return function (e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = e.length); for (var o = 0, s = i; o < n; o += 3, s += 3)t.x = e[s], t.y = e[s + 1], t.z = e[s + 2], t.applyMatrix4(this), e[s] = t.x, e[s + 1] = t.y, e[s + 2] = t.z; return e } }, r.prototype.makeTranslation = function (t, e, i) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this }, r.prototype.multiplyScalar = function (t) { var e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, r.prototype.set = function (t, e, i, n, o, s, r, a, h, u, c, l, f, y, d, p) { var x = this.elements; return x[0] = t, x[4] = e, x[8] = i, x[12] = n, x[1] = o, x[5] = s, x[9] = r, x[13] = a, x[2] = h, x[6] = u, x[10] = c, x[14] = l, x[3] = f, x[7] = y, x[11] = d, x[15] = p, this }, r.prototype.makeScale = function (t, e, i) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this }, e.default = r }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n, o = function () { function t(t, e) { for (var i = 0; i < e.length; i++) { var n = e[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } return function (e, i, n) { return i && t(e.prototype, i), n && t(e, n), e } }(), s = i(1), r = (n = s) && n.__esModule ? n : { default: n }, a = i(0); var h = function () { function t(e, i) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.start = void 0 !== e ? e : new r.default, this.end = void 0 !== i ? i : new r.default } return o(t, [{ key: "set", value: function (t, e) { return this.start.copy(t), this.end.copy(e), this } }, { key: "copy", value: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this } }, { key: "center", value: function (t) { return (t || new r.default).addVectors(this.start, this.end).multiplyScalar(.5) } }, { key: "delta", value: function (t) { return (t || new r.default).subVectors(this.end, this.start) } }, { key: "distanceSq", value: function () { return this.start.distanceToSquared(this.end) } }, { key: "distance", value: function () { return this.start.distanceTo(this.end) } }, { key: "at", value: function (t, e) { var i = e || new r.default; return this.delta(i).multiplyScalar(t).add(this.start) } }, { key: "closestPointToPointParameter", value: function (t, e) { var i = new r.default, n = new r.default; i.subVectors(t, this.start), n.subVectors(this.end, this.start); var o = n.dot(n), s = n.dot(i) / o; return e && (s = (0, a.clamp)(s, 0, 1)), s } }, { key: "closestPointToPoint", value: function (t, e, i) { var n = this.closestPointToPointParameter(t, e), o = i || new r.default; return this.delta(o).multiplyScalar(n).add(this.start) } }, { key: "applyMatrix4", value: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this } }, { key: "equals", value: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }, { key: "clone", value: function () { return (new t).copy(this) } }, { key: "intersectLine", value: function (t) { var e = this.end.clone().sub(this.start), i = t.end.clone().sub(t.start), n = t.start.clone().sub(this.start), o = e.clone().cross(i), s = n.clone().cross(i); if (0 !== n.dot(e)) { var r = s.dot(o) / o.lengthSq(); if (!(r > 1 || isNaN(r))) { var a = this.start.clone().add(e.clone().multiplyScalar(r)); return a.clone().sub(t.start).lengthSq() + a.clone().sub(t.end).lengthSq() <= t.distanceSq() ? a : void 0 } } } }]), t }(); e.default = h }, function (t, e, i) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Vector3 = e.rect = e.quaternion = e.point = e.Plane = e.Matrix4 = e.sign = e.radToDeg = e.degToRad = e.clamp = e.lineSegment = e.Line3 = void 0; var n = f(i(8)), o = f(i(2)), s = i(0), r = f(i(7)), a = f(i(6)), h = f(i(5)), u = f(i(3)), c = f(i(4)), l = f(i(1)); function f(t) { return t && t.__esModule ? t : { default: t } } var y = { Line3: n.default, lineSegment: o.default, clamp: s.clamp, degToRad: s.degToRad, radToDeg: s.radToDeg, sign: s.sign, Matrix4: r.default, Plane: a.default, point: h.default, quaternion: u.default, rect: c.default, Vector3: l.default }; e.Line3 = n.default, e.lineSegment = o.default, e.clamp = s.clamp, e.degToRad = s.degToRad, e.radToDeg = s.radToDeg, e.sign = s.sign, e.Matrix4 = r.default, e.Plane = a.default, e.point = h.default, e.quaternion = u.default, e.rect = c.default, e.Vector3 = l.default, e.default = y }]) });
//# sourceMappingURL=cornerstoneMath.min.js.map